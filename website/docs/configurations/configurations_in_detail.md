
# More about Configurations
More details about some important configurations

## Planner Configuration

In TaskWeaver, the Planner is responsible for generating a plan to accomplish the user's task. The plan is a sequence of steps, where each step will be executed by the Code Interpreter.
Taken the response from the Code Interpreter or new requests from the user as input, the Planner will update the plan and move on to the next step.


- `planner.example_base_path`:	The folder to store planner examples. The default value is `${AppBaseDir}/planner_examples`. 
If you want to create your own planner examples, you can add them to this folder. More details about `example` can referred to [example](../customization/example/example.md).
- `planner.prompt_compression`: At times, lengthy conversations with the Planner may exceed the input limitations of the LLM model. 
To address this issue, we can compress the chat history and send it to the LLM model. The default value for this setting is `false`.
More details about `prompt_compression` can be referred to [prompt_compression](../advanced/compression).
- `planner.use_experience`: Whether to use experience summarized from the previous chat history in planner. The default value is `false`.


## Session Configuration

`session` is the entrance of TaskWeaver. 
It is responsible for the communication between the user and TaskWeaver.
You can refer to [taskweaver_as_a_lib](../usage/library.md) to see how to setup a TaskWeaver session and start chatting with TaskWeaver.


- `max_internal_chat_round_num`: the maximum number of internal chat rounds between Planner and Code Interpreter. 
  If the number of internal chat rounds exceeds this number, the session will be terminated. 
  The default value is `10`.
- `roles`: the roles included for the conversation. The default value is `["planner", "code_interpreter"]`.
  Roles can be divided into two parts: planner roles and worker roles. In TaskWeaver, the Planner is fixed.
  - Planner roles are responsible for generating a plan to accomplish the user's task, while worker roles are responsible for executing the plan generated by the Planner.
  - TaskWeaver supports 3 worker roles: `code_interpreter`, `code_interpreter_cli_only`, and `code_interpreter_plugin_only`.
    - `code_interpreter`: it will generate Python code to fulfill the user's request.
    - `code_interpreter_plugin_only`: please refer to [plugin_only_mode](../customization/plugin/plugin_only.md) for more details.
    - `code_interpreter_cli_only`: allow users to directly communicate with the Command Line Interface (CLI) in natural language. CodeInterpreter will generate CLI commands (e.g., bash/powershell), instead of Python code, to fulfill the user's request.
  - If you do not specify `planner` in the roles, you will enter the `no-planner` mode. It allows users to directly communicate with the worker role, such as `code_interpreter`.
    In this mode, users can only send messages to the `CodeInterpreter` and receive messages from the `CodeInterpreter`.
    Note that only single worker role is allowed in the `no-planner` mode because all user requests will be sent to the worker role directly.
    Here is an example:

``````bash
 =========================================================
 _____         _     _       __
|_   _|_ _ ___| | _ | |     / /__  ____ __   _____  _____
  | |/ _` / __| |/ /| | /| / / _ \/ __ `/ | / / _ \/ ___/
  | | (_| \__ \   < | |/ |/ /  __/ /_/ /| |/ /  __/ /
  |_|\__,_|___/_|\_\|__/|__/\___/\__,_/ |___/\___/_/
=========================================================
TaskWeaver: I am TaskWeaver, an AI assistant. To get started, could you please enter your request?
Human: generate 10 random numbers
>>> [PYTHON]Starting... 
import numpy as np
random_numbers = np.random.rand(10)
random_numbers
>>> [VERIFICATION]
NONE
>>> [STATUS]Starting...         
SUCCESS
>>> [RESULT]
The execution of the generated python code above has succeeded

The result of above Python code after execution is:
array([0.09918602, 0.68732778, 0.44413814, 0.4756623 , 0.48302334,
       0.8286594 , 0.80994359, 0.35677263, 0.45719317, 0.68240194])
>>> [CODEINTERPRETER->PLANNER]
The following python code has been executed:
```python
import numpy as np
random_numbers = np.random.rand(10)
random_numbers
```

The execution of the generated python code above has succeeded

The result of above Python code after execution is:
array([0.09918602, 0.68732778, 0.44413814, 0.4756623 , 0.48302334,
       0.8286594 , 0.80994359, 0.35677263, 0.45719317, 0.68240194])
TaskWeaver: The following python code has been executed:
```python
import numpy as np
random_numbers = np.random.rand(10)
random_numbers
```

The execution of the generated python code above has succeeded

The result of above Python code after execution is:
array([0.09918602, 0.68732778, 0.44413814, 0.4756623 , 0.48302334,
       0.8286594 , 0.80994359, 0.35677263, 0.45719317, 0.68240194])
``````


## Embedding Configuration

In TaskWeaver, we support various embedding models to generate embeddings for auto plugin selection.


- `llm.embedding_api_type`: The type of the embedding API. We support the following types:
  - openai
  - qwen
  - ollama
  - sentence_transformers
  - glm

- `llm.embedding_model`: The embedding model name. The model name should be aligned with `llm.embedding_api_type`.
   We only list some embedding models we have tested below:
  - openai
    - text-embedding-ada-002
  - qwen
    - text-embedding-v1
  - ollama
    - llama2
  - sentence_transformers
    - all-mpnet-base-v2
    - multi-qa-mpnet-base-dot-v1
    - all-distilroberta-v1
    - all-MiniLM-L12-v2
    - multi-qa-MiniLM-L6-cos-v1
  - zhipuai
    - embedding-2
You also can use other embedding models supported by the above embedding APIs.